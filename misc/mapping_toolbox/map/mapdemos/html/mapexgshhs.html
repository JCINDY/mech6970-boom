
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Converting Coastline Data (GSHHS) to Shapefile Format</title><meta name="generator" content="MATLAB 7.12"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2011-02-02"><meta name="DC.source" content="mapexgshhs.m"><link rel="stylesheet" type="text/css" href="../../../matlab/demos/private/style.css"></head><body><div class="header"><div class="left"><a href="matlab:edit mapexgshhs">Open mapexgshhs.m in the Editor</a></div><div class="right"><a href="matlab:echodemo mapexgshhs">Run in the Command Window</a></div></div><div class="content"><h1>Converting Coastline Data (GSHHS) to Shapefile Format</h1><!--introduction--><p>The Global Self-consistent Hierarchical High-resolution Shorelines (GSHHS) data set, by Paul Wessel and Walter H. F. Smith, provides a consistent set of hierarchically arranged closed polygons. They can be used to construct base maps, or in applications or analyses that involve things like geographic searches or the statistical properties of coastlines.</p><p>This demo illustrates how to:</p><div><ul><li>Extract a subset of coastline data from the Global Self-consistent   Hierarchical High-resolution Shorelines (GSHHS) data set</li><li>Manipulate polygon features to add lakes and other interior water   bodies as inner polygon rings ("holes")</li><li>Save the modified data set to a shapefile for future use in MATLAB&reg;,   or for export to a geographic information system</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Step 1: Define a Working Directory</a></li><li><a href="#2">Step 2: GNU&reg; Unzip and Index the Coarse-Resolution GSHHS Layer</a></li><li><a href="#3">Step 3: Import the GSHHS Data for South America</a></li><li><a href="#5">Step 4: Examine the Data Set</a></li><li><a href="#9">Step 5: Extract the Top Two Levels into Separate Geostruct Arrays</a></li><li><a href="#12">Step 6: Merge Level 2 Polygons into Level 1</a></li><li><a href="#15">Step 7: Save Results in a Shapefile</a></li><li><a href="#16">Step 8: Validate the Shapefile</a></li><li><a href="#20">Reference</a></li><li><a href="#21">Additional Data</a></li><li><a href="#22">Credits</a></li></ul></div><h2>Step 1: Define a Working Directory<a name="1"></a></h2><p>This demo creates several temporary files and uses the variable <tt>workingDirectory</tt> to denote their location.  The value used here is determined by the output of the <tt>tempdir</tt> command, but you could easily customize this.</p><pre class="codeinput">workingDirectory = tempdir;
</pre><h2>Step 2: GNU&reg; Unzip and Index the Coarse-Resolution GSHHS Layer<a name="2"></a></h2><p>GSHHS is available in wide range of spatial resolutions.  This demo uses the lowest-resolution data, from the binary file <tt>gshhs_c.b</tt>.  A GNU zipped copy of this file is included in the Mapping Toolbox&#8482; demo directory, on the MATLAB path.</p><p>Use the MATLAB <tt>gunzip</tt> function to decompress <tt>gshhs_c.b.gz</tt> and create the file <tt>gshhs_c.b</tt> in the location indicated by <tt>workingDirectory</tt>. Then create an index file, <tt>gshhs_c.i</tt>, in the same directory.  In general, having an index file helps to accelerate later calls to the <tt>gshhs</tt> function.  Note that when you use the <tt>'createindex'</tt> option, <tt>gshhs</tt> does not extract data.</p><pre class="codeinput">files = gunzip(<span class="string">'gshhs_c.b.gz'</span>, workingDirectory);
filename = files{1};
indexfile = gshhs(filename, <span class="string">'createindex'</span>);
</pre><h2>Step 3: Import the GSHHS Data for South America<a name="3"></a></h2><p>Select data for a specific latitude-longitude quadrangle and import it as a Mapping Toolbox "geostruct" array:</p><pre class="codeinput">latlim = [-60  15];
lonlim = [-90 -30];
S = gshhs(filename, latlim, lonlim);
</pre><p>If you have finished extracting data, you can remove the decompressed GSHHS file and the index file.</p><pre class="codeinput">delete(filename)
delete(indexfile)
</pre><h2>Step 4: Examine the Data Set<a name="5"></a></h2><p>Examine the first element of the geostruct array <tt>S</tt>.  In addition to the <tt>Lat</tt> and <tt>Lon</tt> coordinate arrays, note the various attribute fields that are present.</p><pre class="codeinput">S(1)
</pre><pre class="codeoutput">
ans = 

          Geometry: 'Polygon'
       BoundingBox: [2x2 double]
               Lat: [1x972 double]
               Lon: [1x972 double]
             South: -53.9004
             North: 71.9942
              West: 191.8947
              East: 325.2054
              Area: 3.7652e+007
             Level: 1
       LevelString: 'land'
         NumPoints: 971
     FormatVersion: 3
            Source: 'WVS'
    CrossGreenwich: 0
          GSHHS_ID: 1

</pre><p>GSHHS comprises four levels of shorelines:</p><div><ul><li>Level 1 - "Land"</li><li>Level 2 - "Lake"</li><li>Level 3 - "Island in lake"</li><li>Level 4 - "Pond in island in lake"</li></ul></div><p>Check to see which levels the data you've imported includes.  The <tt>Level</tt> field contains numerical level numbers.</p><pre class="codeinput">levels = [S.Level];
unique(levels)
</pre><pre class="codeoutput">
ans =

     1     2     3

</pre><p>The <tt>LevelString</tt> field provides their interpretation.  For example,</p><pre class="codeinput">S(104).LevelString
</pre><pre class="codeoutput">
ans =

lake

</pre><p>shows that feature 104 is a lake (a Level 2 feature).</p><p>In this example, due either to the low resolution or to spatial subsetting, no Level 4 features are present.</p><h2>Step 5: Extract the Top Two Levels into Separate Geostruct Arrays<a name="9"></a></h2><p>This demo manipulates the top two levels of the GSHHS hierarchy, inserting each "lake" into the surrounding land mass.</p><p>Extract GSHHS Level 1 (exterior coastlines of continents and oceanic islands):</p><pre class="codeinput">L1 = S(levels == 1);
</pre><p>Extract Level 2 (coastlines of lakes and seas within Level 1 polygons):</p><pre class="codeinput">L2 = S(levels == 2);
</pre><p>To see their spatial relationships, you can map Level 1 edges as blue lines and Level 2 edges as red lines:</p><pre class="codeinput">figure
axesm(<span class="string">'mercator'</span>, <span class="string">'MapLatLimit'</span>, latlim, <span class="string">'MapLonLimit'</span>, lonlim)
gridm; mlabel; plabel
geoshow([L1.Lat], [L1.Lon], <span class="string">'Color'</span>, <span class="string">'blue'</span>)
geoshow([L2.Lat], [L2.Lon], <span class="string">'Color'</span>, <span class="string">'red'</span>)
tightmap
</pre><img vspace="5" hspace="5" src="mapexgshhs_01.png" alt=""> <h2>Step 6: Merge Level 2 Polygons into Level 1<a name="12"></a></h2><p>Define an anonymous predicate function to detect bounding-box intersections (returning true if a pair of bounding boxes intersect and false otherwise). Inputs <tt>A</tt> and <tt>B</tt> are 2-by-2 bounding-box matrices of the form</p><pre>  [min(lon)  min(lat)
   max(lon)  max(lat)].</pre><pre class="codeinput">boxesIntersect = <span class="keyword">...</span>
    @(A,B) (~(any(A(2,:) &lt; B(1,:)) || any(B(2,:) &lt; A(1,:))));
</pre><p>For convenience in looping over them, copy the Level 1 bounding boxes to a 3-D array:</p><pre class="codeinput">L1boxes = reshape([L1.BoundingBox],[2 2 numel(L1)]);
</pre><p>Check each Level 1 - Level 2 pair of features for possible intersection.  See if <tt>polybool</tt> returns any output or not, but avoid calling <tt>polybool</tt> unless a bounding box intersection is detected first:</p><pre class="codeinput"><span class="keyword">for</span> k = 1:numel(L2)
    <span class="keyword">for</span> j = 1:numel(L1)
        <span class="comment">% See if bounding boxes intersect</span>
        <span class="keyword">if</span> boxesIntersect(L2(k).BoundingBox, L1boxes(:,:,j))
            <span class="comment">% See if actual features intersect</span>
            <span class="keyword">if</span> ~isempty(polybool(<span class="string">'intersection'</span>, <span class="keyword">...</span>
                L2(k).Lon, L2(k).Lat, L1(j).Lon, L1(j).Lat))
                <span class="comment">% Reverse level 2 vertex order before merge to</span>
                <span class="comment">% correctly orient inner rings</span>
                L1(j).Lon = [L1(j).Lon fliplr(L2(k).Lon) NaN];
                L1(j).Lat = [L1(j).Lat fliplr(L2(k).Lat) NaN];
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>Step 7: Save Results in a Shapefile<a name="15"></a></h2><p>With a single call to <tt>shapewrite</tt>, you can create a trio of files,</p><pre> gshhs_c_SouthAmerica.shp
 gshhs_c_SouthAmerica.shx
 gshhs_c_SouthAmerica.dbf</pre><p>in your working directory.</p><pre class="codeinput">shapepath = fullfile(workingDirectory,<span class="string">'gshhs_c_SouthAmerica'</span>);
shapewrite(L1, shapepath)
</pre><h2>Step 8: Validate the Shapefile<a name="16"></a></h2><p>To validate the results of <tt>shapewrite</tt>, read the new shapefile into the geostruct array <tt>southAmerica</tt>:</p><pre class="codeinput">southAmerica = shaperead(shapepath, <span class="string">'UseGeoCoords'</span>, true)
</pre><pre class="codeoutput">
southAmerica = 

79x1 struct array with fields:
    Geometry
    BoundingBox
    Lon
    Lat
    South
    North
    West
    East
    Area
    Level
    LevelString
    NumPoints
    FormatVersi
    Source
    CrossGreenw
    GSHHS_ID

</pre><p>Note that the two longest fieldnames, <tt>'FormatVersion'</tt> and <tt>'CrossGreenwich'</tt>, have been truncated to 11 characters. This happened during the call to <tt>shapewrite</tt> and is unavoidable because of a rigid 11-character limit in the xBASE tables (.DBF format) used to store attributes in shapefiles. (In general, when writing shapefiles you may want to re-define fieldnames longer than 11 characters in order to avoid or control the effects of automatic truncation.)</p><p>Optionally, remove the new shapefiles from your working directory. (This demo needs to clean up after itself; in a real application you would probably want to omit this step.)</p><pre class="codeinput">delete([shapepath <span class="string">'.*'</span>])
</pre><p>Display the geostruct imported from the new shapefile.  Note the various "holes" in the South America polygon indicating lakes and shorelines of other extended bodies of water in the interior of the continent.</p><pre class="codeinput">figure(<span class="string">'Renderer'</span>,<span class="string">'zbuffer'</span>)
ax = axesm(<span class="string">'mercator'</span>, <span class="string">'MapLatLimit'</span>, latlim, <span class="string">'MapLonLimit'</span>, lonlim);
set(ax, <span class="string">'Color'</span>, <span class="string">'cyan'</span>)
gridm; mlabel; plabel
geoshow(southAmerica, <span class="string">'FaceColor'</span>, [0.15 0.8 0.15])
tightmap
</pre><img vspace="5" hspace="5" src="mapexgshhs_02.png" alt=""> <h2>Reference<a name="20"></a></h2><p>Wessel, P., and W. H. F. Smith, 1996, A global self-consistent, hierarchical, high-resolution shoreline database, Journal of Geophysical Research, Vol. 101, pp. 8741-8743.</p><h2>Additional Data<a name="21"></a></h2><p>The complete GSHHS data set may be downloaded from the U.S. National Oceanic and Atmospheric Administration (NOAA) web site. Follow the links from</p><p><a href="http://www.mathworks.com/support/tech-notes/2100/2101.html#gshhs">http://www.mathworks.com/support/tech-notes/2100/2101.html#gshhs</a></p><h2>Credits<a name="22"></a></h2><p>The GSHHS data file is provided in the Mapping Toolbox courtesy of Dr. Paul Wessel of the University of Hawaii and Dr. Walter H. F. Smith of NOAA.</p><p>For more information, run:</p><pre>  &gt;&gt; type gshhs_c.txt</pre><p class="footer">Copyright 2005-2008 The MathWorks, Inc.<br>
          Published with MATLAB&reg; 7.12</p><p class="footer" id="trademarks">MATLAB and Simulink are registered trademarks of The MathWorks, Inc.  Please see <a href="http://www.mathworks.com/trademarks">www.mathworks.com/trademarks</a> for a list of other trademarks owned by The MathWorks, Inc.  Other product or brand names are trademarks or registered trademarks of their respective owners.</p></div><!--
##### SOURCE BEGIN #####
%% Converting Coastline Data (GSHHS) to Shapefile Format
%
% The Global Self-consistent Hierarchical High-resolution Shorelines
% (GSHHS) data set, by Paul Wessel and Walter H. F. Smith, provides a
% consistent set of hierarchically arranged closed polygons. They can be
% used to construct base maps, or in applications or analyses that
% involve things like geographic searches or the statistical properties
% of coastlines.
%
% This demo illustrates how to:
%
% * Extract a subset of coastline data from the Global Self-consistent
%   Hierarchical High-resolution Shorelines (GSHHS) data set
% * Manipulate polygon features to add lakes and other interior water
%   bodies as inner polygon rings ("holes")
% * Save the modified data set to a shapefile for future use in MATLAB(R),
%   or for export to a geographic information system

% Copyright 2005-2008 The MathWorks, Inc.
% $Revision: 1.1.6.8 $  $Date: 2008/05/14 22:01:20 $

%% Step 1: Define a Working Directory
% This demo creates several temporary files and uses the variable
% |workingDirectory| to denote their location.  The value used here is
% determined by the output of the |tempdir| command, but you could
% easily customize this.
workingDirectory = tempdir;

%% Step 2: GNU(R) Unzip and Index the Coarse-Resolution GSHHS Layer
% GSHHS is available in wide range of spatial resolutions.  This demo uses
% the lowest-resolution data, from the binary file |gshhs_c.b|.  A GNU
% zipped copy of this file is included in the Mapping Toolbox(TM) demo
% directory, on the MATLAB path.
%
% Use the MATLAB |gunzip| function to decompress |gshhs_c.b.gz| and create
% the file |gshhs_c.b| in the location indicated by |workingDirectory|.
% Then create an index file, |gshhs_c.i|, in the same directory.  In
% general, having an index file helps to accelerate later calls to the
% |gshhs| function.  Note that when you use the |'createindex'| option,
% |gshhs| does not extract data.

files = gunzip('gshhs_c.b.gz', workingDirectory);
filename = files{1};
indexfile = gshhs(filename, 'createindex');

%% Step 3: Import the GSHHS Data for South America
% Select data for a specific latitude-longitude quadrangle and import it
% as a Mapping Toolbox "geostruct" array:
latlim = [-60  15];
lonlim = [-90 -30];
S = gshhs(filename, latlim, lonlim);

%%
% If you have finished extracting data, you can remove the decompressed
% GSHHS file and the index file.
delete(filename)
delete(indexfile)

%% Step 4: Examine the Data Set
% Examine the first element of the geostruct array |S|.  In addition to the
% |Lat| and |Lon| coordinate arrays, note the various attribute fields that
% are present.
S(1)

%%
% GSHHS comprises four levels of shorelines:
%
% * Level 1 - "Land"
% * Level 2 - "Lake"
% * Level 3 - "Island in lake"
% * Level 4 - "Pond in island in lake"
%
% Check to see which levels the data you've imported includes.  The
% |Level| field contains numerical level numbers.
levels = [S.Level];
unique(levels)

%%
% The |LevelString| field provides their interpretation.  For example,
S(104).LevelString

%%
% shows that feature 104 is a lake (a Level 2 feature).
%
% In this example, due either to the low resolution or to spatial
% subsetting, no Level 4 features are present.

%% Step 5: Extract the Top Two Levels into Separate Geostruct Arrays
% This demo manipulates the top two levels of the GSHHS hierarchy,
% inserting each "lake" into the surrounding land mass.
%
% Extract GSHHS Level 1 (exterior coastlines of continents and oceanic
% islands):
L1 = S(levels == 1);

%%
% Extract Level 2 (coastlines of lakes and seas within Level 1
% polygons):
L2 = S(levels == 2);

%%
% To see their spatial relationships, you can map Level 1 edges as blue
% lines and Level 2 edges as red lines:
figure
axesm('mercator', 'MapLatLimit', latlim, 'MapLonLimit', lonlim)
gridm; mlabel; plabel
geoshow([L1.Lat], [L1.Lon], 'Color', 'blue')
geoshow([L2.Lat], [L2.Lon], 'Color', 'red')
tightmap

%% Step 6: Merge Level 2 Polygons into Level 1
%
% Define an anonymous predicate function to detect bounding-box
% intersections (returning true if a pair of bounding boxes intersect and
% false otherwise). Inputs |A| and |B| are 2-by-2 bounding-box matrices of
% the form
%
%    [min(lon)  min(lat)
%     max(lon)  max(lat)].

boxesIntersect = ...
    @(A,B) (~(any(A(2,:) < B(1,:)) || any(B(2,:) < A(1,:))));

%%
% For convenience in looping over them, copy the Level 1 bounding boxes to
% a 3-D array:
L1boxes = reshape([L1.BoundingBox],[2 2 numel(L1)]);

%%
% Check each Level 1 - Level 2 pair of features for possible
% intersection.  See if |polybool| returns any output or not, but avoid
% calling |polybool| unless a bounding box intersection is detected
% first:
for k = 1:numel(L2)
    for j = 1:numel(L1)
        % See if bounding boxes intersect
        if boxesIntersect(L2(k).BoundingBox, L1boxes(:,:,j))
            % See if actual features intersect
            if ~isempty(polybool('intersection', ...
                L2(k).Lon, L2(k).Lat, L1(j).Lon, L1(j).Lat))
                % Reverse level 2 vertex order before merge to
                % correctly orient inner rings
                L1(j).Lon = [L1(j).Lon fliplr(L2(k).Lon) NaN];
                L1(j).Lat = [L1(j).Lat fliplr(L2(k).Lat) NaN];
            end
        end
    end
end

%% Step 7: Save Results in a Shapefile
% With a single call to |shapewrite|, you can create a trio of files,
%
%   gshhs_c_SouthAmerica.shp
%   gshhs_c_SouthAmerica.shx
%   gshhs_c_SouthAmerica.dbf
%
% in your working directory.
shapepath = fullfile(workingDirectory,'gshhs_c_SouthAmerica');
shapewrite(L1, shapepath)

%% Step 8: Validate the Shapefile
%
% To validate the results of |shapewrite|, read the new shapefile
% into the geostruct array |southAmerica|:
southAmerica = shaperead(shapepath, 'UseGeoCoords', true)

%%
% Note that the two longest fieldnames, |'FormatVersion'| and
% |'CrossGreenwich'|, have been truncated to 11 characters. This
% happened during the call to |shapewrite| and is unavoidable because of
% a rigid 11-character limit in the xBASE tables (.DBF format) used to
% store attributes in shapefiles. (In general, when writing shapefiles
% you may want to re-define fieldnames longer than 11 characters in
% order to avoid or control the effects of automatic truncation.)

%%
% Optionally, remove the new shapefiles from your working directory.
% (This demo needs to clean up after itself; in a real application you
% would probably want to omit this step.)
delete([shapepath '.*'])

%%
% Display the geostruct imported from the new shapefile.  Note the various
% "holes" in the South America polygon indicating lakes and shorelines of
% other extended bodies of water in the interior of the continent.
figure('Renderer','zbuffer')
ax = axesm('mercator', 'MapLatLimit', latlim, 'MapLonLimit', lonlim);
set(ax, 'Color', 'cyan')
gridm; mlabel; plabel
geoshow(southAmerica, 'FaceColor', [0.15 0.8 0.15])
tightmap

%% Reference
% Wessel, P., and W. H. F. Smith, 1996, A global
% self-consistent, hierarchical, high-resolution shoreline database,
% Journal of Geophysical Research, Vol. 101, pp. 8741-8743.

%% Additional Data
% The complete GSHHS data set may be downloaded from the U.S. National
% Oceanic and Atmospheric Administration (NOAA) web site. Follow the links
% from
%
% http://www.mathworks.com/support/tech-notes/2100/2101.html#gshhs

%% Credits
%
% The GSHHS data file is provided in the Mapping Toolbox courtesy of Dr.
% Paul Wessel of the University of Hawaii and Dr. Walter H. F. Smith of
% NOAA.
%
% For more information, run: 
%    
%    >> type gshhs_c.txt


displayEndOfDemoMessage(mfilename)

##### SOURCE END #####
--></body></html>